package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.53

import (
	"backend/models/discounts"
	"backend/models/products"
	"backend/models/types"
	"context"
	"errors"
	"fmt"
	"graphql/graph/model"
	"strconv"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}

// CreateDiscount is the resolver for the createDiscount field.
func (r *mutationResolver) CreateDiscount(ctx context.Context, input model.NewDiscount) (*model.Discount, error) {
	prodId, err := strconv.ParseUint(input.ProductID, 10, 64)
	if err != nil {
		return nil, err
	}

	prod := products.Product{}
	res := r.Db.First(&prod, prodId)
	if res.Error != nil {
		return nil, res.Error
	}

	newDiscont := discounts.Discount{NewPrice: types.PriceType(input.NewPrice), Style: input.Style}
	prod.Discounts = append(prod.Discounts, newDiscont)
	updateRes := r.Db.Save(&prod)
	return &model.Discount{ID: "value"}, updateRes.Error
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input *model.NewProduct) (*model.Product, error) {
	newProd := products.Product{
		Name:        input.Name,
		Desctiption: input.Description,
		Price:       types.PriceType(input.Count),
		IsActive:    input.IsActive,
		Count:       uint64(input.Count),
		Picture:     types.DbFile{Path: input.Picture}}
	db := r.Db
	res := db.Create(&newProd)
	return &model.Product{ID: fmt.Sprintf("%d", newProd.ID)}, res.Error
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, input *model.NewCollection) (*model.Collection, error) {
	prodIds := make([][]uint, 0, len(input.ProductIds))
	for _, el := range input.ProductIds {
		if el == nil {
			return nil, errors.New("undefinded product id")
		}
		id, err := strconv.ParseUint(*el, 10, 64)
		if err != nil {
			return nil, errors.New("could not parse product id")
		}
		prodIds = append(prodIds, []uint{uint(id)})
	}
	foundProd := []*products.Product{}
	res := r.Db.Where("id IN ?", prodIds).Find(&foundProd)
	if res.Error != nil {
		return nil, res.Error
	}
	newCollection := products.Collection{
		Name:        input.Name,
		Description: input.Description,
		Picture:     types.DbFile{Path: input.Picture},
		Products:    foundProd}
	r.Db.Create(&newCollection)
	return &model.Collection{ID: fmt.Sprintf("%d", newCollection.ID)}, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}

// Discounts is the resolver for the discounts field.
func (r *queryResolver) Discounts(ctx context.Context) ([]*model.Discount, error) {
	db := r.Db
	foundDiscounts := []discounts.Discount{}
	res := db.Find(&foundDiscounts)
	if res.Error != nil {
		return nil, res.Error
	}
	gqlDiscounts := make([]*model.Discount, 0, len(foundDiscounts))
	for _, el := range foundDiscounts {
		gqlDiscounts = append(gqlDiscounts, &model.Discount{
			ID:             fmt.Sprintf("%d", el.ID),
			ProductID:      fmt.Sprintf("%d", *el.ProductID),
			NewPrice:       float64(el.NewPrice),
			Style:          el.Style,
			ExpirationDate: el.ExpirationDate.String(),
		})
	}
	return gqlDiscounts, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	db := r.Db
	foundProducts := []products.Product{}
	res := db.Find(&foundProducts)
	if res.Error != nil {
		return nil, res.Error
	}
	returnedProducts := make([]*model.Product, 0, len(foundProducts))
	for _, el := range foundProducts {
		returnedProducts = append(returnedProducts,
			&model.Product{
				ID:          fmt.Sprintf("%d", el.ID),
				Name:        el.Name,
				Description: el.Desctiption,
				Price:       float64(el.Price),
				IsActive:    el.IsActive,
				Count:       int(el.Count),
				Picture:     el.Picture.Path})
	}
	return returnedProducts, res.Error
}

// Collections is the resolver for the collections field.
func (r *queryResolver) Collections(ctx context.Context) ([]*model.Collection, error) {
	foundCollections := []products.Collection{}
	res := r.Db.Find(&foundCollections)
	if res.Error != nil {
		return nil, res.Error
	}
	resCollections := make([]*model.Collection, 0, len(foundCollections))
	for _, el := range foundCollections {
		resCollections = append(resCollections, &model.Collection{
			ID:          fmt.Sprintf("%d", el.ID),
			Name:        el.Name,
			Description: el.Description,
			Picture:     el.Picture.Path,
		})
	}
	return resCollections, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
